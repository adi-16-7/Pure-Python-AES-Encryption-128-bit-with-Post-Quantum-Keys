import math
import pyspx.shake256_128s as sphincs
import os, binascii

# Key generation: private + public key


r_Con = [['0x01','0x00','0x00','0x00'], ['0x02','0x00','0x00','0x00'], ['0x04','0x00','0x00','0x00'], ['0x08','0x00','0x00','0x00'], ['0x10','0x00','0x00','0x00'], ['0x20','0x00','0x00','0x00'], ['0x40','0x00','0x00','0x00'], ['0x80','0x00','0x00','0x00'], ['0x1B','0x00','0x00','0x00'], ['0x36','0x00','0x00','0x00']]

subByte_Box = [
				['0x63','0x7C','0x77','0x7B','0xF2','0x6B','0x6F','0xC5','0x30','0x01','0x67','0x2B','0xFE','0xD7','0xAB','0x76'],
				['0xCA','0x82','0xC9','0x7D','0xFA','0x59','0x47','0xF0','0xAD','0xD4','0xA2','0xAF','0x9C','0xA4','0x72','0xC0'],
				['0xB7','0xFD','0x93','0x26','0x36','0x3F','0xF7','0xCC','0x34','0xA5','0xEF','0xF1','0x71','0xD8','0x31','0x15'],
				['0x04','0xC7','0x23','0xC3','0x18','0x96','0x05','0x9A','0x07','0x12','0x80','0xE2','0xEB','0x27','0xB2','0x75'],
				['0x09','0x83','0x2C','0x1A','0x1B','0x6E','0x5A','0xA0','0x52','0x3B','0xD6','0xB3','0x29','0xE3','0x2F','0x84'],
			    ['0x53','0xD1','0x00','0xED','0x20','0xFC','0xB1','0x5B','0x6A','0xCB','0xBE','0x39','0x4A','0x4C','0x58','0xCF'],
			    ['0xD0','0xEF','0xAA','0xFB','0x43','0x4D','0x33','0x85','0x45','0xF9','0x02','0x7F','0x50','0x3C','0x9F','0xA8'],
			    ['0x51','0xA3','0x40','0x8F','0x92','0x9D','0x38','0xF5','0xBC','0xB6','0xDA','0x21','0x10','0xFF','0xF3','0xD2'],
			    ['0xCD','0x0C','0x13','0xEC','0x5F','0x97','0x44','0x17','0xC4','0xA7','0x7E','0x3D','0x64','0x5D','0x19','0x73'],
			    ['0x60','0x81','0x4F','0xDC','0x22','0x2A','0x90','0x88','0x46','0xEE','0xB8','0x14','0xDE','0x5E','0x0B','0xDB'],
			    ['0xE0','0x32','0x3A','0x0A','0x49','0x06','0x24','0x5C','0xC2','0xD3','0xAC','0x62','0x91','0x95','0xE4','0x79'],
			    ['0xE7','0xC8','0x37','0x6D','0x8D','0xD5','0x4E','0xA9','0x6C','0x56','0xF4','0xEA','0x65','0x7A','0xAE','0x08'],
			    ['0xBA','0x78','0x25','0x2E','0x1C','0xA6','0xB4','0xC6','0xE8','0xDD','0x74','0x1F','0x48','0xBD','0x8B','0x8A'],
			    ['0x70','0x3E','0xB5','0x66','0x48','0x03','0xF6','0x0E','0x61','0x35','0x57','0x89','0x86','0xC1','0x1D','0x9E'],
			    ['0xE1','0xF8','0x98','0x11','0x69','0xD9','0x8E','0x94','0x9B','0x1E','0x87','0xE9','0xCE','0x55','0x28','0xDF'],
			    ['0x8C','0xA1','0x89','0x0D','0xBD','0xE6','0x42','0x68','0x41','0x99','0x2D','0x0F','0xB0','0x54','0xBB','0x16']
			] 


subByte_Box_Inv = [

			        ['0x52','0x09','0x6a','0xd5','0x30','0x36','0xa5','0x38', '0xbf', '0x40', '0xa3', '0x9e', '0x81', '0xf3', '0xd7', '0xfb'],
			        ['0x7c','0xe3','0x39','0x82','0x9b','0x2f','0xff' '0x87', '0x34', '0x8e', '0x43', '0x44', '0xc4', '0xde', '0xe9', '0xcb'],
			        ['0x54','0x7b','0x94','0x32','0xa6','0xc2','0x23' '0x3d', '0xee', '0x4c', '0x95', '0x0b', '0x42', '0xfa', '0xc3', '0x4e'],
			        ['0x08','0x2e','0xa1','0x66','0x28','0xd9','0x24' '0xb2', '0x76', '0x5b', '0xa2', '0x49', '0x6d', '0x8b', '0xd1', '0x25'],
			        ['0x72','0xf8','0xf6','0x64','0x86','0x68','0x98' '0x16', '0xd4', '0xa4', '0x5c', '0xcc', '0x5d', '0x65', '0xb6', '0x92'],
			        ['0x6c','0x70','0x48','0x50','0xfd','0xed','0xb9' '0xda', '0x5e', '0x15', '0x46', '0x57', '0xa7', '0x8d', '0x9d', '0x84'],
			        ['0x90','0xd8','0xab','0x00','0x8c','0xbc','0xd3' '0x0a', '0xf7', '0xe4', '0x58', '0x05', '0xb8', '0xb3', '0x45', '0x06'],
			        ['0xd0','0x2c','0x1e','0x8f','0xca','0x3f','0x0f' '0x02', '0xc1', '0xaf', '0xbd', '0x03', '0x01', '0x13', '0x8a', '0x6b'],
			        ['0x3a','0x91','0x11','0x41','0x4f','0x67','0xdc' '0xea', '0x97', '0xf2', '0xcf', '0xce', '0xf0', '0xb4', '0xe6', '0x73'],
			        ['0x96','0xac','0x74','0x22','0xe7','0xad','0x35' '0x85', '0xe2', '0xf9', '0x37', '0xe8', '0x1c', '0x75', '0xdf', '0x6e'],
			        ['0x47','0xf1','0x1a','0x71','0x1d','0x29','0xc5' '0x89', '0x6f', '0xb7', '0x62', '0x0e', '0xaa', '0x18', '0xbe', '0x1b'],
			        ['0xfc','0x56','0x3e','0x4b','0xc6','0xd2','0x79' '0x20', '0x9a', '0xdb', '0xc0', '0xfe', '0x78', '0xcd', '0x5a', '0xf4'],
			        ['0x1f','0xdd','0xa8','0x33','0x88','0x07','0xc7' '0x31', '0xb1', '0x12', '0x10', '0x59', '0x27', '0x80', '0xec', '0x5f'],
			        ['0x60','0x51','0x7f','0xa9','0x19','0xb5','0x4a' '0x0d', '0x2d', '0xe5', '0x7a', '0x9f', '0x93', '0xc9', '0x9c', '0xef'],
			        ['0xa0','0xe0','0x3b','0x4d','0xae','0x2a','0xf5' '0xb0', '0xc8', '0xeb', '0xbb', '0x3c', '0x83', '0x53', '0x99', '0x61'],
			        ['0x17','0x2b','0x04','0x7e','0xba','0x77','0xd6' '0x26', '0xe1', '0x69', '0x14', '0x63', '0x55', '0x21', '0x0c', '0x7d']
        		]


E_Table = 	[
					['0x01','0x03','0x05','0x0F','0x11','0x33','0x55','0xFF', '0x1A', '0x2E', '0x72', '0x96', '0xA1', '0xF8', '0x13', '0x35'],
			        ['0x5F','0xE1','0x38','0x48','0xD8','0x73','0x95','0xA4', '0xF7', '0x02', '0x06', '0x0A', '0x1E', '0x22', '0x66', '0xAA'],
			        ['0xE5','0x34','0x5C','0xE4','0x37','0x59','0xEB','0x26', '0x6A', '0xBE', '0xD9', '0x70', '0x90', '0xAB', '0xE6', '0x31'],
			        ['0x53','0xF5','0x04','0x0C','0x14','0x3C','0x44','0xCC', '0x4F', '0xD1', '0x68', '0xB8', '0xD3', '0x6E', '0xB2', '0xCD'],
			        ['0x4C','0xD4','0x67','0xA9','0xE0','0x3B','0x4D','0xD7', '0x62', '0xA6', '0xF1', '0x08', '0x18', '0x28', '0x78', '0x88'],
			        ['0x83','0x9E','0xB9','0xD0','0x6B','0xBD','0xDC','0x7F', '0x81', '0x98', '0xB3', '0xCE', '0x49', '0xDB', '0x76', '0x9A'],
			        ['0xB5','0xC4','0x57','0xF9','0x10','0x30','0x50','0xF0', '0x0B', '0x1D', '0x27', '0x69', '0xBB', '0xD6', '0x61', '0xA3'],
			        ['0xFE','0x19','0x2B','0x7D','0x87','0x92','0xAD','0xEC', '0x2F', '0x71', '0x93', '0xAE', '0xE9', '0x20', '0x60', '0xA0'],
			        ['0xFB','0x16','0x3A','0x4E','0xD2','0x6D','0xB7','0xC2', '0x5D', '0xE7', '0x32', '0x56', '0xFA', '0x15', '0x3F', '0x41'],
			        ['0xC3','0x5E','0xE2','0x3D','0x47','0xC9','0x40','0xC0', '0x5B', '0xED', '0x2C', '0x74', '0x9C', '0xBF', '0xDA', '0x75'],
			        ['0x9F','0xBA','0xD5','0x64','0xAC','0xEF','0x2A','0x7E', '0x82', '0x9D', '0xBC', '0xDF', '0x7A', '0x8E', '0x89', '0x80'],
			        ['0x9B','0xB6','0xC1','0x58','0xE8','0x23','0x65','0xAF', '0xEA', '0x25', '0x6F', '0xB1', '0xC8', '0x43', '0xC5', '0x54'],
			        ['0xFC','0x1F','0x21','0x63','0xA5','0xF4','0x07','0x09', '0x1B', '0x2D', '0x77', '0x99', '0xB0', '0xCB', '0x46', '0xCA'],
			        ['0x45','0xCF','0x4A','0xDE','0x79','0x8B','0x86','0x91', '0xA8', '0xE3', '0x3E', '0x42', '0x67', '0x51', '0xF3', '0x0E'],
			        ['0x12','0x36','0x5A','0xEE','0x29','0x7B','0x8D','0x8C', '0x8F', '0x8A', '0x85', '0x94', '0xA7', '0xF2', '0x0D', '0x17'],
			        ['0x39','0x4B','0xDD','0x7C','0x84','0x97','0xA2','0xFD', '0x1C', '0x24', '0x6C', '0xB4', '0xC7', '0x52', '0xF6', '0x01']
			]


L_Table = 	[

					[ '','0x00','0x19','0x01','0x32','0x02','0x1A','0xC6','0x4B', '0xC7', '0x1B', '0x68', '0x33', '0xEE', '0xDF', '0x03'],
					['0x64','0x04','0xE0','0x0E','0x34','0x8D','0x81' '0xEF', '0x4C', '0x71', '0x08', '0xC8', '0xF8', '0x69', '0x1C', '0xC1'],
					['0x7D','0xC2','0x1D','0xB5','0xF9','0xB9','0x27', '0x6A', '0x4D', '0xE4', '0xA6', '0x72', '0x9A', '0xC9', '0x09', '0x78'],
					['0x65','0x2F','0x8A','0x05','0x21','0x0F','0xE1' '0x24', '0x12', '0xF0', '0x82', '0x45', '0x35', '0x93', '0xDA', '0x8E'],
					['0x96','0x8F','0xDB','0xBD','0x36','0xD0','0xCE', '0x94', '0x13', '0x5C', '0xD2', '0xF1', '0x40', '0x46', '0x83', '0x38'],
					['0x66','0xDD','0xFD','0x30','0xBF','0x06', '0x8B', '0x62', '0xB3', '0x25', '0xE2', '0x98', '0x22', '0x88', '0x91','0x10'],
					['0x7E','0x6E','0x48','0xC3','0xA3','0xB6','0x1E', '0x42', '0x3A', '0x6B', '0x28', '0x54', '0xFA', '0x85', '0x3D', '0xBA'],
					['0x2B','0x79','0x0A','0x15','0x9B','0x9F','0x5E', '0xCA', '0x4E', '0xD4', '0xAC', '0xE5', '0xF3', '0x73', '0xA7', '0x57'],
					['0xAF','0x58','0xA8','0x50','0xF4','0xEA','0xD6', '0x74', '0x4F', '0xAE', '0xE9', '0xD5', '0xE7', '0xE6', '0xAD', '0xE8'],
					['0x2C','0xD7','0x75','0x7A','0xEB','0x16','0x0B', '0xF5', '0x59', '0xCB', '0x5F', '0xB0', '0x9C', '0xA9', '0x51', '0xA0'],
					['0x7F','0x0C','0xF6','0x6F','0x17','0xC4','0x49', '0xEC', '0xD8', '0x43', '0x1F', '0x2D', '0xA4', '0x76', '0x7B', '0xB7'],
					['0xCC','0xBB','0x3E','0x5A','0xFB','0x60','0xB1', '0x86', '0x3B', '0x52', '0xA1', '0x6C', '0xAA', '0x55', '0x29', '0x9D'],
					['0x97','0xB2','0x87','0x90','0x61','0xBE','0xDC' '0xFC', '0xBC', '0x95', '0xCF', '0xCD', '0x37', '0x3F', '0x5B', '0xD1'],
					['0x53','0x39','0x84','0x3C','0x41','0xA2','0x6D', '0x47', '0x14', '0x2A', '0x9E', '0x5D', '0x56', '0xF2', '0xD3', '0xAB'],
					['0x44','0x11','0x92','0xD9','0x23','0x20','0x2E', '0x89', '0xB4', '0x7C', '0xB8', '0x26', '0x77', '0x99', '0xE3', '0xAS'],
					['0x67','0x4A','0xED','0xDE','0xC5','0x31','0xFE', '0x18', '0x0D', '0x63', '0x8C', '0x80', '0xC0', '0xF7', '0x70', '0x07']

			]



mix_column = [
				[2, 3, 1, 1,],
				[1, 2, 3, 1,],
				[1, 1, 2, 3,],
				[3, 1, 1, 2,]
			]


def substitution(key): #using subByte_Box
	arr = rotword_Col_Gen(key[3])
	#print(arr)
	index = 0
	for i in arr:	
		#row = int(i[2])
		#col = int(i[3])
		row = i[2]
		col = i[3]
		if(ord(row) > 57):
			row = int(ord(row) - 87)
		if(ord(col) > 57):
			col = int(ord(col) - 87)
		row = int(row)
		col = int(col)
		#print(type(row),type(col))
		#print(subByte_Box[row][col])
		arr[index] = subByte_Box[row][col].lower()
		index = index + 1
	return arr


def substitutionInv(key, dtxt): #using subByte_Box
	arr = rotword_Col_Gen(key[3])
	#print(arr)
	index = 0
	for i in arr:	
		#row = int(i[2])
		#col = int(i[3])
		row = i[2]
		col = i[3]
		if(ord(row) > 57):
			row = int(ord(row) - 87)
		if(ord(col) > 57):
			col = int(ord(col) - 87)
		row = int(row)
		col = int(col)
		#print(type(row),type(col))
		#print(subByte_Box[row][col])
		arr[index] = subByte_Box_Inv[row][col].lower()
		index = index + 1
	return arr


def rotword_Col_Gen(col):
	arr = []
	for i in range(0, 4):
		arr.append(col[i]);

	temp = arr[0]
	for i in range(1, 4):
		arr[i-1] = arr[i]
	arr[3] = temp
	return arr;


def key_gen(key, index):
	key_gen = []
	rotword = substitution(key)
	#print(rotword)
	for i in range(0, 4):
		arr = key[i];
		
		#print("Arr", arr)
		
		arr1 = []

		# tempArr = []

		if(i > 0):
			rotword = key_gen[len(key_gen)-1]
			
		for j in range(0, 4):
			if(i == 0):
				temp = int(arr[j], 16) ^ int(rotword[j], 16) ^ int(r_Con[index][j], 16) 
			else:
				temp = int(arr[j], 16) ^ int(rotword[j], 16)
			convert = hex(temp)
			if(len(convert) == 3):
				convert = convert + '0'
				c1 = convert[3]
				c2 = convert[2]
				convert = convert[0:2]
				convert = convert + c1 + c2
			#print("temp", temp)
			
			arr1.append(convert)
		key_gen.append(arr1)
	
	#print(key_gen)
	return key_gen

def create_2D_4x4(s): 
	rows, cols = (4, 4) 
	arr = [[0 for i in range(cols)] for j in range(rows)]
	index = 0;
	for i in range(rows):
		for j in range(cols):
			arr[i][j] = hex(ord(s[index])) #storing it in a column form 
			index = index + 1
	return arr;


def create_2D():
	rows, cols = (4, 4) 
	arr = [[0 for i in range(cols)] for j in range(rows)]
	return arr;

#PRIVATE_KEY = "T47FCSPROJECTPAY"
# key = "TEAMSCORPIAN1234"
key = "Thats my Kung Fu"
KEYS = []
key_0 = create_2D_4x4(key)
#print(key_0)
KEYS.append(key_0)
# KEYS.append(key_gen(KEYS[0], 0))
# KEYS.append(key_gen(KEYS[1], 1))
for i in range(10):
	KEYS.append(key_gen(KEYS[i], i))
#	print(KEYS[i+1])

#print(KEYS)

bit = '0x00'
halfByte = ['0x00', '0x00', '0x00', '0x00']

def calc(msg):
	addBits = 16 - len(msg)%16
	if(addBits % 16 == 0):
		return 0, 0, len(msg)//16
	totalBits = len(msg) + addBits
	blocks = totalBits//16
	addHalfBytes = addBits//4
	addBits = addBits - addHalfBytes*4
	return addBits, addHalfBytes, blocks


def arrange(hexMsg):
	count = 0
	arr = []
	Blocks = []
	for i in hexMsg:
		#print(i)
		arr.append(i)
		count = count + 1
		if(count == 4):
			Blocks.append(arr)
			count = 0
			arr = []
			# print(Blocks)
	return Blocks


def decryption(msg):
	convToHex(msg)

def convToHex(msg):
	block = []
	arr = []
	count = 0
	addBits, addHalfBytes, blocks = calc(msg)
	
	#print(addBits, addHalfBytes, blocks)
	
	for i in msg:
		temp = hex(int(ord(i)))
		arr.append(temp)
		count = count + 1
		if(count == 4):
			count = 0
			block.append(arr)
			arr = []
	if(addBits != 0):
		while(addBits != 0):
			arr.append(bit)
			addBits = addBits - 1
		block.append(arr)
		arr = []
	while(addHalfBytes != 0):
		block.append(halfByte)
		addHalfBytes = addHalfBytes - 1
	return block

msg = str(input())
hexMsg = []
hexMsg.append(convToHex(msg))
dtxt = msg
#print(hexMsg)
BLOCKS = []
BLOCKS.append(arrange(hexMsg[0]))
BLOCKS = BLOCKS[0]
#print(BLOCKS, len(BLOCKS))


seed = os.urandom(sphincs.crypto_sign_SEEDBYTES)
public_key, secret_key = sphincs.generate_keypair(seed)
# print("Public key:", binascii.hexlify(public_key))
# print("Private key:", binascii.hexlify(secret_key))

# # Sign message and verify signature
message = b'Two One Nine Two'
signature = sphincs.sign(message, secret_key)


# # valid = sphincs.verify(message, signature, public_key)
# # print("Message:", message)
# # print("Signature:", binascii.hexlify(signature))
# print("Signature valid?", valid)

# # Verify tampered message + signature
# message = b'Tampered msg'
# valid = sphincs.verify(message, signature, public_key)
# print("Tampered message:", message)
# print("Tampered signature valid?", valid)



def hexToBin(hexa):
	# Initialising hex string 
	ini_string = hexa
	# Code to convert hex to binary 
	res = "{0:08b}".format(int(hexa, 16)) 	
	return res


def for_one(hexa):
	return int(hexa, 16)


def for_two(hexa):
	binary = hexToBin(hexa)
	dec = int(hexa, 16)
	if(binary[0] == '0'):
		return dec << 1
	return (dec << 1) ^ 27


def for_three(hexa):
	binary = hexToBin(hexa)
	dec = int(hexa, 16)
	if(binary[0] == '0'):
		res = dec << 1
		return dec ^ res
	else:
		res = (dec << 1) ^ 27
		return dec ^ res


def substitutionBytesE(matrix):
	# print(matrix)
	for i in range(0, 4):
		for j in range(0, 4):
			# print(matrix[i][j])
			elmn = matrix[i][j]
			row = elmn[2]
			col = elmn[3]
			if(ord(row) > 57):
				row = int(ord(row) - 87)
			if(ord(col) > 57):
				col = int(ord(col) - 87)
			row = int(row)
			col = int(col)
			matrix[i][j] = E[row][col].lower()
	return matrix


def substitutionBytesL(matrix):
	# print(matrix)
	for i in range(0, 4):
		for j in range(0, 4):
			# print(matrix[i][j])
			elmn = matrix[i][j]
			row = elmn[2]
			col = elmn[3]
			if(ord(row) > 57):
				row = int(ord(row) - 87)
			if(ord(col) > 57):
				col = int(ord(col) - 87)
			row = int(row)
			col = int(col)
			matrix[i][j] = L[row][col].lower()
	return matrix


def mixColInv(matrix, key):
	arr1 = []
	arr2 = []
	storeTmp = create_2D()
	for i in range (4):
		arr = matrix[k]
		mixColumn = key[k]
		val = []
		for j in range(4):
			val1 = substitutionBytesL(arr[j])
			val2 = substitutionBytesL(key[j])
			sum = hex(int(val1, 16) + int(val2, 16))
			val.append(substitutionBytesE(sum))
		arr1.append(val)



def mixCol(matrix):
	#print(matrix)
	mixColumn = []
	arr1 = []
	arr2 = []
	storeTmp = create_2D()
	for i in range (4):
		m_c = mix_column[i]
		for k in range(4):
			arr = matrix[k]
			for j in range(4):
				if(m_c[j] == 1):
					arr1.append(for_one(arr[j]))
				if(m_c[j] == 2):
					arr1.append(for_two(arr[j]))
				if(m_c[j] == 3):
					arr1.append(for_three(arr[j]))
			check = 0
			for i in arr1:
				check = check ^ i
			check = hex(check)
			if(len(check) == 3):
				check = check + '0'
				c1 = check[3]
				c2 = check[2]
				check = check[0:2]
				check = check + c1 + c2
			if(len(check) == 5):
				val = str(check[3:])
				check = check[0:2]
				check = check + val
			arr1 = []
			arr2.append(check)
		mixColumn.append(arr2)
		arr2 = []
	#print(mixColumn)
	for i in range(4):
		for j in range(4):
			storeTmp[i][j] = mixColumn[j][i]
	#print(storeTmp)
	return storeTmp


def shiftRowInv(matrix):
	# print(matrix)
	tempMatrix = create_2D()
	for i in range(4):
		for j in range(4):
			tempMatrix[i][j] = matrix[j][i]
	#matrix = tempMatrix
	for i in range(1, 4):
		store = []
		temp = i
		for j in range(0, i):
			#while(temp != 0):
			#	temp = temp - 1
			store.append(tempMatrix[i][j])
		for j in range(i, 4):
			tempMatrix[j-1][i] = tempMatrix[i][j]
		index = 0	
		for j in range(4-i, 4):
			tempMatrix[j][i] = store[index]
			index = index + 1
	
	for i in range(4):
		for j in range(4):
			matrix[i][j] = tempMatrix[j][i]

	#print(matrix)

def substitutionBytesInv(matrix, dtxt):
	# print(matrix)
	for i in range(0, 4):
		for j in range(0, 4):
			# print(matrix[i][j])
			elmn = matrix[i][j]
			row = elmn[2]
			col = elmn[3]
			if(ord(row) > 57):
				row = int(ord(row) - 87)
			if(ord(col) > 57):
				col = int(ord(col) - 87)
			row = int(row)
			col = int(col)
			matrix[i][j] = subByte_Box[row][col].lower()
	return matrix



def shiftRow(matrix):
	# print(matrix)
	tempMatrix = create_2D()
	for i in range(4):
		for j in range(4):
			tempMatrix[i][j] = matrix[j][i]
	#matrix = tempMatrix
	for i in range(1, 4):
		store = []
		temp = i
		for j in range(0, i):
			#while(temp != 0):
			#	temp = temp - 1
			store.append(tempMatrix[i][j])
		for j in range(i, 4):
			tempMatrix[i][j-i] = tempMatrix[i][j]
		index = 0	
		for j in range(4-i, 4):
			tempMatrix[i][j] = store[index]
			index = index + 1
	
	for i in range(4):
		for j in range(4):
			matrix[i][j] = tempMatrix[j][i]

	#print(matrix)

def substitutionBytes(matrix):
	# print(matrix)
	for i in range(0, 4):
		for j in range(0, 4):
			# print(matrix[i][j])
			elmn = matrix[i][j]
			row = elmn[2]
			col = elmn[3]
			if(ord(row) > 57):
				row = int(ord(row) - 87)
			if(ord(col) > 57):
				col = int(ord(col) - 87)
			row = int(row)
			col = int(col)
			matrix[i][j] = subByte_Box[row][col].lower()
	return matrix


def decrypton(dcrpt):
	for i in range(len(KEYS)-2, 0, -1):
		dcrpt.append(addRoundKey(M_C[i], KEYS[i]))
		substitutionBytesInv(dcrpt[i], dtxt)
		shiftRowInv(dcrpt)
		mixColInv(KEYS[i])


def addRoundKey(block, key):
	xorMatrix = []
	for i in range(0, 4):
		arr = []
		arr1 = block[i]
		arr2 = key[i]
		for j in range(0, 4):
			temp = int(arr1[j], 16) ^ int(arr2[j], 16)
			convert = hex(temp)
			if(len(convert) == 3):
				convert = convert + '0'
				c1 = convert[3]
				c2 = convert[2]
				convert = convert[0:2]
				convert = convert + c1 + c2
			#print("temp", temp)
			
			arr.append(convert)	
		xorMatrix.append(arr)
	return xorMatrix

M_C = []

def ciphered():
	result = []
	block = BLOCKS[0]
	for i in range(0, len(KEYS)):
		key = KEYS[i]
		XOR = []
		#print("BK ", block)
		#print("KEY ", key)
		XOR.append(addRoundKey(block, key))
		XOR = XOR[0]
		if(i == len(KEYS)-1):
			block = XOR
			M_C.append(block)
			break
		#print("RK ", XOR)
		substitutionBytes(XOR)
		#print("SB ", XOR)
		shiftRow(XOR)
		if(i == len(KEYS)-2):
			block = XOR
			continue
		#print("SR ", XOR)
		block = (mixCol(XOR))
		M_C.append(block)
		#print("MC ", block)
		
	#print("CT ", XOR)
	
	return block;

dcrpt = []

def dText():
	decryption(dcrpt)
	return(dtxt)


def validity():
  valid = sphincs.verify(message, signature, public_key)
  #print(type(valid))
  # print(valid)
  if(valid == True):
    return dText();
  else:
    return 'Invalid'

print(ciphered())
print(validity())

#print(XOR) 
